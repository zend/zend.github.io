<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Linux/Unix网络编程指南(Socket 编程)</title>
    <meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yourdomain.com/20080210-183.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Your awesome title</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/about/index.html">About</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux/Unix网络编程指南(Socket 编程)</h1>
    <p class="post-meta">Feb 10, 2008 • admin</p>
  </header>

  <article class="post-content">
    <p><strong>介绍 <br />
**Hey! Socket 编程让你沮丧吗？从 man pages 中很难得到有用的信息吗？你想 跟上时代去做一做 Internet 程序，但是为你在调用 connect() 前的 bind() 的结构而愁眉不展？… <br />
好了，我现在已经来了，我将和所有人共享我的知识了。如果你了解 C 语言并想穿过 网络编程的沼泽，那么你来对地方了。 <br />
**读者</strong> <br />
这个文档是写成一个指南，而不是参考书。如果你刚开始 socket 编程并想找一本 入门书，那么你是我的读者。这可不是一本完全的 socket 编程书。 <br />
<strong>平台和编译器 <br />
**这篇文章中的大多数代码都在一台 Linux PC 上用 GNU 的 gcc 成功编译过。 而且他们在一台 HPUX 上用 gcc 也成功编译过。但是注意，并不是每个代码 片段都独立测试过。 <br />
<a name="more"></a>——————————————————————————– <br />
**目录</strong>： <br />
<a href="http://www.winterxy.com/blog/000050.html#什么是 socket？">什么是套接口？ </a><br />
<a href="http://www.winterxy.com/blog/000050.html#Internet 套接口的两种类型">Internet 套接口的两种类型 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#网络理论">网络理论 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#structs">struct–要么了解他们，要么等异形入侵地球</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#Convert the Natives!">Convert the Natives! </a><br />
<a href="http://www.winterxy.com/blog/000050.html#IP 地址和如何处理他们">IP 地址和如何处理他们 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#socket()--得到文件描述符！">socket()–得到文件描述符！</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#bind()--我在哪个端口">bind()–我们在哪个端口？</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#connect()--Hello！">connect()–Hello！</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#listen">listen()–有人给我打电话吗？</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#accept">accept()–“Thank you for calling port 3490.” </a><br />
<a href="http://www.winterxy.com/blog/000050.html#send">send() 和 recv()–Talk to me, baby! </a><br />
<a href="http://www.winterxy.com/blog/000050.html#sendto">sendto() 和 recvfrom()–Talk to me, DGRAM-style </a><br />
<a href="http://www.winterxy.com/blog/000050.html#close">close() 和 shutdown()–滚开！</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#getpeername">getpeername()–你是谁？</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#gethostname">gethostname()–我是谁？</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#DNS">DNS–你说“白宫”，我说 “198.137.240.100”</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#Client-Server Background">客户-服务器背景知识 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#简单的服务器">简单的服务器</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#简单的客户程序">简单的客户端 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#数据报 Sockets">数据报 Socket</a> <br />
<a href="http://www.winterxy.com/blog/000050.html#阻塞">阻塞 </a><br />
<a href="http://www.winterxy.com/blog/000050.html#select()--多路同步 I/O">select()–多路同步 I/O，酷！</a> </p>

<p>参考资料 <br />
Disclaimer and Call for Help <br />
——————————————————————————– <br />
<a name="什么是 socket？">什么是 socket？</a> <br />
你始终听到人们谈论着 “socket”，而你不知道他的确切含义。那么，现在我告诉你： 他是使用 Unix 文件描述符 (fiel descriptor) 和其他程序通讯的方式。 <br />
什么？ <br />
Ok–你也许听到一些 Unix 高手 (hacker) 这样说：“呀，Unix 中所有的东西就是文件！”那个家伙也许正在说到一个事实：Unix 程序在执行任何形式的 I/O 的时候，程序是在读或者写一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数。但是(注意后面的话)，这个文件可能是一个网络连接，FIFO，管道，终端，磁盘上的文件 或者什么其他的东西。Unix 中所有的东西是文件！因此，你想和 Internet 上别 的程序通讯的时候，你将要通过文件描述符。最好相信刚才的话。 <br />
现在你脑海中或许冒出这样的念头：“那么我从哪里得到网络通讯的文件描述符呢，聪明 人？”无论如何，我要回答这个问题：你利用系统调用 socket()。他返回套接口描 述符 (socket descriptor)，然后你再通过他来调用 send() 和 recv()。 <br />
“但是…”，你可能现在叫起来，“如果他是个文件描述符，那么为什么不用一般的调用 read() 和 write() 来通过套接口通讯？”简单的答案是：“你可以使用 一般的函数！”。详细的答案是：“你可以，但是使用 send() 和 recv() 让你更好的控制数据传输。” <br />
有这样一个事实：在我们的世界上，有很多种套接口。有 DARPA Internet 地址 (Internet 套接口)，本地节点的路径名 (Unix 套接口)，CCITT X.25 地址 (你可以完全忽略 X.25 套接口)。 也许在你的 Unix 机器上还有其他的。我们在这里只讲第一种：Internet 套接口。 <br />
——————————————————————————– <br />
<a name="Internet 套接口的两种类型">Internet 套接口的两种类型 </a><br />
什么意思？有两种 Internet 套接口？是的。不，我在撒谎。其实还有很多，但是我可不想 吓着你。我们这里只讲两种。 Except for this sentence, where I’m going to tell you that “Raw Sockets” are also very powerful and you should look them up. <br />
好了，好了。那两种类型是什么呢？一种是 “Stream Sockets”，另外一种是 “Datagram Sockets”。我们以后谈到他们的时候也会用到 “SOCK_STREAM” 和 “SOCK_DGRAM”。数据报套接口有时也叫“无连接套接口”(如果你确实要连接的时候用 connect()。) <br />
流式套接口是可靠的双向通讯的数据流。如果你向套接口安顺序输出“1，2”，那么他们 将安顺序“1，2”到达另一边。他们也是无错误的传递的，有自己的错误控制。 <br />
有谁在使用流式套接口？你可能听说过 telnet，不是吗？他就使用流式套接口。你需要你所输入的字符按顺序到达，不是 吗？同样，WWW 浏览器使用的 HTTP 协议也使用他们。实际上，当你通过端口80 telnet 到一个 WWW 站点，然后输入 “GET pagename” 的时候，你也可以得到 HTML 的内容。 <br />
为什么流式套接口可以达到高质量的数据传输？他使用了“传输控制协议 (The Transmission Control Protocol)”，也叫 “TCP” (请参考 RFC-793 获得详细资料。)TCP 控制你的数据 按顺序到达并且没有错误。你也许听到 “TCP” 是因为听到过 “TCP/IP”。这里的 IP 是指 “Internet 协议”(请参考 RFC-791.) IP 只是处理 Internet 路由而已。 <br />
那么数据报套接口呢？为什么他叫无连接呢？为什么他是不可靠的呢？恩，有这样的事实：如果你发送一个数据报，他可能到达，他可能次序颠倒了。如果他到达，那么在这个包的内部是无错误的。 <br />
数据报也使用 IP 作路由，但是他不选择 TCP。他使用“用户数据报协议 (User Datagram Protocol)”，也叫 “UDP” (请参考 RFC-768.) <br />
为什么他们是无连接的呢？主要原因是因为他并不象流式套接口那样维持一个连接。 你只要建立一个包，在目标信息中构造一个 IP 头，然后发出去。不需要连接。应用程序有： tftp, bootp 等等。 <br />
“够了！”你也许会想，“如果数据丢失了这些程序如何正常工作？”我的朋友，每个程序在 UDP 上有自己的协议。例如，tftp 协议每发出一个包，收到者发回一个包来说“我收到了！” (一个“命令正确应答”也叫“ACK” 包)。如果在一定时间内(例如5秒)，发送方没有收到应答， 他将重新发送，直到得到 ACK。这一点在实现 SOCK_DGRAM 应用程序的时候非常重要。 <br />
——————————————————————————– <br />
<a name="网络理论">网络理论 </a><br />
既然我刚才提到了协议层，那么现在是讨论网络究竟如何工作和演示 SOCK_DGRAM 的工作。当然，你也可以跳过这一段，如果你认为 已经熟悉的话。 <br />
朋友们，现在是学习 数据封装 (Data Encapsulation) 的时候了！ 这非常非常重要。It’s so important that you might just learn about it if you take the networks course here at Chico State ;-). 主要的内容是：一个包，先是被第一个协议(在这里是 TFTP )包装(“封装”)， 然后，整个数据(包括 TFTP 头)被另外一个协议(在这里是 UDP )封装，然后下 一个( IP )，一直重复下去，直到硬件(物理)层( Ethernet )。 <br />
当另外一台机器接收到包，硬件先剥去 Ethernet 头，内核剥去 IP 和 UDP 头，TFTP 程序再剥去 TFTP 头，最后得到数据。 <br />
现在我们终于讲到臭名远播的 网络分层模型 (Layered Network Model)。这种网络模型在描述网络系统上相对其他模型有很多优点。例如，你可以写一个套接口 程序而不用关心数据的物理传输(串行口，以太网，连接单元接口 (AUI) 还是其他介质。 因为底层的程序为你处理他们。实际的网络硬件和拓扑对于程序员来说是透明的。 <br />
不说其他废话了，我现在列出整个层次模型。如果你要参加网络考试，可一定要记住： <br />
应用层 (Application) <br />
表示层 (Presentation) <br />
会话层 (Session) <br />
传输层 (Transport) <br />
网络层 (Network) <br />
数据链路层 (Data Link) <br />
物理层 (Physical) <br />
物理层是硬件(串口，以太网等等)。应用层是和硬件层相隔最远的–他是用户和网络 交互的地方。 <br />
这个模型如此通用，如果你想，你可以把他作为修车指南。把他应用到 Unix，结果是: <br />
应用层 (Application Layer) (telnet, ftp, 等等) <br />
传输层 (Host-to-Host Transport Layer) (TCP, UDP) <br />
Internet 层 (Internet Layer) (IP 和路由) <br />
网络访问层 (Network Access Layer) (网络层，数据链路层和物理层) <br />
现在，你可能看到这些层次如何协调来封装原始的数据了。 <br />
看看建立一个简单的数据包有多少工作？哎呀，你将不得不使用 “cat” 来完成 他们！简直是笑话。对于流式套接口你要作的是 send() 发送数据。对于数据报 式套接口你按照你选择的方式封装数据然后用 sendto()。内核将为你建立传输 层和 Internet 层，硬件完成网络访问层。这就是现代科技。 <br />
现在结束我们的网络理论速成班。哦，忘记告诉你关于路由的事情了。但是我不准备谈他。 如果你真的想知道，那么参考 IP RFC。如果你从来不曾了解他，也没有 关系，你还活着不是吗。 <br />
——————————————————————————– <br />
<a name="structs">structs </a><br />
终于到达这里了，终于谈到编程了。在这章，我将谈到被套接口用到的各种数据类型。因为 他们中的一些太重要了。 <br />
首先是简单的一个：socket descriptor。他是下面的类型： <br />
  int <br />
仅仅是一个常见的 int。 <br />
从现在起，事情变得不可思议了。请跟我一起忍受苦恼吧。注意这样的事实： 有两种字节排列顺序：重要的字节在前面(有时叫 “octet”)，或者不重要的字节在前面。 前一种叫“网络字节顺序 (Network Byte Order)”。有些机器在内部是按照这个顺序储存数据，而另外一些则不然。当我说某数据必须按照 NBO 顺序，那么你要调用函数(例 如 htons() )来将他从本机字节顺序 (Host Byte Order) 转换过来。如果我 没有提到 NBO， 那么就让他是本机字节顺序吧。 <br />
我的第一个结构(TM)–struct sockaddr. 这个数据结构 为许多类型的套接口储存套接口地址信息： <br />
<font color="#0000ff">struct</font> sockaddr { <br />
    <font color="#0000ff">unsigned</font> <font color="#0000ff">short</font>  sa_family;  /* address family, AF_xxx    */ <br />
    <font color="#0000ff">char</font>       sa_data<a href="http://www.winterxy.com/blog/000050.html#close">14</a>; /* 14 bytes of protocol address */ <br />
}; <br />
sa_family 能够是各种各样的事情，但是在这篇文章中是 “AF_INET”。 sa_data 为套接口储存目标地址和端口信息。看上去很笨拙，不是吗。 <br />
为了对付 struct sockaddr，程序员创造了一个并列的结构： struct sockaddr_in (“in” 代表 “Internet”.) <br />
<font color="#0000ff">struct</font> sockaddr_in { <br />
    <font color="#0000ff">short</font> <font color="#0000ff">int</font>     sin_family; /* Address family        */ <br />
    <font color="#0000ff">unsigned</font> <font color="#0000ff">short</font> <font color="#0000ff">int</font> sin_port;  /* Port number         */ <br />
    <font color="#0000ff">struct</font> in_addr   sin_addr;  /* Internet address       */ <br />
    <font color="#0000ff">unsigned</font> <font color="#0000ff">char</font>   sin_zero<a href="http://www.winterxy.com/blog/000050.html#bind()--我在哪个端口">8</a>; /* Same size as struct sockaddr */ </p>

<p>}; <br />
这个数据结构让可以轻松处理套接口地址的基本元素。注意 sin_zero (他 被加入到这个结构，并且长度和 struct sockaddr 一样) 应该使用函数 bzero() 或 memset() 来全部置零。 Also, and this is the important bit, a pointer to a struct sockaddr_in can be cast to a pointer to a struct sockaddr and vice-versa. 这样的话 即使 socket() 想要的是 struct sockaddr *， 你仍然可以使用 struct sockaddr_in，and cast it at the last minute! 同时，注意 sin_family 和 struct sockaddr 中的 sa_family 一致并能够设置为 “AF_INET”。最后， sin_port 和 sin_addr 必须是网络字节顺序 (Network Byte Order)！ <br />
你也许会反对道：”但是，怎么让整个数据结构 struct in_addr sin_addr 按照网络字节顺序呢?” 要知道这个问题的答案，我们就要仔细的看一 看这个数据结构： struct in_addr, 有这样一个联合 (unions)： <br />
/* Internet address (a structure for historical reasons) */ <br />
  <font color="#0000ff">struct</font> in_addr { <br />
    <font color="#0000ff">unsigned</font> <font color="#0000ff">long</font> s_addr; <br />
  }; <font color="#0000ff"><br /> </font>他曾经是个最坏的联合，但是现在那些日子过去了。如果你声明 “ina” 是 数据结构 struct sockaddr_in 的实例，那么 “ina.sin_addr.s_addr” 就储存4字节的 IP 地址(网络字节顺序)。如果你不幸的 系统使用的还是恐怖的联合 struct in_addr ，你还是可以放心4字 节的 IP 地址是和上面我说的一样(这是因为 #define。) <br />
——————————————————————————– <br />
<a name="Convert the Natives!">Convert the Natives! </a><br />
我们现在到达下个章节。我们曾经讲了很多网络到本机字节顺序，现在是采取行动的时刻了！ <br />
你能够转换两种类型： short (两个字节)和 long (四个字节)。这个 函数对于变量类型 unsigned 也适用。假设你想将 short 从本机字节顺序 转换为网络字节顺序。用 “h” 表示 “本机 (host)”，接着是 “to”，然后用 “n” 表示 “网络 (network)”，最后用 “s” 表示 “short”： h-to-n-s, 或者 htons() (“Host to Network Short”)。 <br />
太简单了… <br />
如果不是太傻的话，你一定想到了组合 “n”，”h”，”s”，和 “l”。但是这里没有 stolh() (“Short to Long Host”) 函数，但是这里有： <br />
htons()–“Host to Network Short” <br />
htonl()–“Host to Network Long” <br />
ntohs()–“Network to Host Short” <br />
ntohl()–“Network to Host Long” <br />
现在，你可能想你已经知道他们了。你也可能想：”如果我改变 char 的顺序会 怎么样呢? 我的 68000 机器已经使用了网络字节顺序，我没有必要去调用 htonl() 转换 IP 地址。” 你可能是对的，但是当你移植你的程序到别的机器上的时候，你的程序将 失败。可移植性！这里是 Unix 世界！记住：在你将数据放到网络上的时候，确信他们是网络字 节顺序。 <br />
最后一点：为什么在数据结构 struct sockaddr_in 中， sin_addr 和 sin_port 需要转换为网络字节顺序，而 sin_family 不需要呢? 答案是：sin_addr 和 sin_port 分别封装在包的 IP 和 UDP 层。因此，他们必须要是网络字节顺序。 但是 sin_family 域只是被内核 (kernel) 使用来决定在数据结构中包含什么类型的地址，所以他应该是本机字节顺序。也即 sin_family 没有 发 送到网络上，他们可以是本机字节顺序。 <br />
——————————————————————————– <br />
<a name="IP 地址和如何处理他们">IP 地址和如何处理他们 </a><br />
现在我们很幸运，因为我们有很多的函数来方便地操作 IP 地址。没有必要用手工计算 他们，也没有必要用 « 操作符来操作 long。 <br />
首先，假设你用 struct sockaddr_in ina，你想将 IP 地址 “132.241.5.10” 储存到其中。你要用的函数是 inet_addr()，转换 numbers-and-dots 格式的 IP 地址到 unsigned long。这个工作可以这样来做： <br />
  ina.sin_addr.s_addr = inet_addr(“132.241.5.10”); <br />
注意：inet_addr() 返回的地址已经是按照网络字节顺序的，你没有必要再去调用 htonl()。 <br />
上面的代码可不是很健壮 (robust)，因为没有错误检查。inet_addr() 在发生错误 的时候返回-1。记得二进制数吗? 在 IP 地址为 255.255.255.255 的时候返回的是 (unsigned)-1！这是个广播地址！记住正确的使用错误检查。 <br />
好了，你现在可以转换字符串形式的 IP 地址为 long 了。那么你有一个数据结构 struct in_addr，该如何按照 numbers-and-dots 格式打印呢? 在这个 时候，也许你要用函数 inet_ntoa() (“ntoa” 意思是 “network to ascii”)： <br />
  printf(“%s”,inet_ntoa(ina.sin_addr)); <br />
他将打印 IP 地址。注意的是：函数 inet_ntoa() 的参数是 struct in_addr，而不是 long。同时要注意的是他返回的是一个指向字符的指针。 在 inet_ntoa 内部的指针静态地储存字符数组，因此每次你调用 inet_ntoa() 的时候他将覆盖以前的内容。例如： <br />
  <font color="#0000ff">char</font> *a1, *a2; <br />
  . <br />
  . <br />
  a1 = inet_ntoa(ina1.sin_addr); /* this is 198.92.129.1 */ <br />
  a2 = inet_ntoa(ina2.sin_addr); /* this is 132.241.5.10 */ <br />
  <font color="#0000ff">printf</font>(“address 1: %s\n”,a1); <br />
  <font color="#0000ff">printf</font>(“address 2: %s\n”,a2); <br />
运行结果是： <br />
  address 1: 132.241.5.10 <br />
  address 2: 132.241.5.10 <br />
如果你想保存地址，那么用 strcpy() 保存到自己的字符数组中。 <br />
这就是这章的内容了。以后，我们将学习转换 “whitehouse.gov” 形式的字符串到正确 的 IP 地址(请看后面的 DNS 一章。) <br />
——————————————————————————– <br />
<a name="socket()--得到文件描述符！">socket()–得到文件描述符！</a> <br />
我猜我不会再扯远了–我必须讲 socket() 这个系统调用了。这里是详细的定义： <br />
  #<font color="#0000ff">include</font> &lt;sys/types.h&gt; <br />
  #<font color="#0000ff">include</font> &lt;sys/socket.h&gt; <br />
  int socket(int domain, int type, int protocol); <br />
但是他们的参数怎么用? 首先，domain 应该设置成 “AF_INET”，就象上面的 数据结构 struct sockaddr_in 中一样。然后，参数 type 告诉内核是 SOCK_STREAM 类型还是 SOCK_DGRAM 类型。最后，把 protocol 设置为 “0”。(注意：有很多种 domain、type， 我不可能一一列出了，请看 socket() 的 man page。当然，还有一个”更好”的方式 去得到 protocol。请看 getprotobyname() 的 man page。) <br />
socket() 只是返回你以后在系统调用种可能用到的 socket 描述符，或者在错误 的时候返回-1。全局变量 errno 中储存错误值。(请参考 perror() 的 man page。) <br />
——————————————————————————– <br />
<a name="bind()--我在哪个端口">bind()–我在哪个端口? </a><br />
一旦你得到套接口，你可能要将套接口和机器上的一定的端口关联起来。(如果你想用 listen() 来侦听一定端口的数据，这是必要一步–MUD 经常告诉你说用命令 “telnet x.y.z 6969”.)如果你只想用 connect()，那么这个步骤没有必要。但是无论如何，请继续读下去。 <br />
这里是系统调用 bind() 的大略： <br />
  #<font color="#0000ff">include</font> &lt;sys/types.h&gt; <br />
  #<font color="#0000ff">include</font> &lt;sys/socket.h&gt; <br />
  <font color="#0000ff">int</font> bind(<font color="#0000ff">int</font> sockfd, <font color="#0000ff">struct</font> sockaddr *my_addr, <font color="#0000ff">int</font> addrlen); <br />
sockfd 是调用 socket 返回的文件描述符。my_addr 是指向 数据结构 struct sockaddr 的指针，他保存你的地址(即端口和 IP 地址) 信息。addrlen 设置为 sizeof(struct sockaddr)。 <br />
简单得很不是吗? 再看看例子： <br />
  #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">define</font> MYPORT 3490   
&nbsp; <font color="#0000ff">main</font>()   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in my\_addr;   
&nbsp;&nbsp;&nbsp; sockfd = socket(AF\_INET, SOCK\_STREAM, 0); /\* do some error checking! \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_family = AF_INET;&nbsp;&nbsp; /\* host byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = htons(MYPORT); /\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = inet\_addr("132.241.5.10");   
&nbsp;&nbsp;&nbsp; bzero(&amp;(my\_addr.sin\_zero), 8);&nbsp;&nbsp;/\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp; /\* don&#8217;t forget your error checking for bind(): \*/   
&nbsp;&nbsp;&nbsp; bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));   
&nbsp;&nbsp;&nbsp;.   
&nbsp;&nbsp;&nbsp;.   
&nbsp;&nbsp;&nbsp;.   
这里也有要注意的几件事情。my\_addr.sin\_port 是网络字节顺序，my\_addr.sin\_addr.s_addr 也是的。另外要注意到的事情是因系统的不同， 包含的头文件也不尽相同，请查阅自己的 man page。   
在 bind() 主题中最后要说的话是，在处理自己的 IP 地址和/或端口的时候，有些工作 是可以自动处理的。   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = 0; /\* choose an unused port at random \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = INADDR\_ANY;&nbsp;/\* use my IP address \*/   
通过将0赋给 my\_addr.sin\_port，你告诉 bind() 自己选择合适的端口。同样， 将 y\_addr.sin\_addr.s\_addr 设置为 INADDR\_ANY，你告诉他自动填上 他所运行的机器的 IP 地址。   
如果你一向小心谨慎，那么你可能注意到我没有将 INADDR\_ANY 转换为网络字节顺序！这是因为我知道内部的东西：INADDR\_ANY 实际上就是 0！即使你 改变字节的顺序，0依然是0。但是完美主义者说安全第一，那么看下面的代码：   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = htons(0); /\* choose an unused port at random \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = htonl(INADDR\_ANY);&nbsp;/\* use my IP address \*/   
你可能不相信，上面的代码将可以随便移植。   
bind() 在错误的时候依然是返回-1，并且设置全局变量 errno。   
在你调用 bind() 的时候，你要小心的另一件事情是：不要采用小于1024的端口号。所有小于1024的端口号都 被系统保留！你可以选择从1024到65535(如果他们没有被别的程序使用的话)。   
你要注意的另外一件小事是：有时候你根本不需要调用他。如果你使用 connect() 来和远程机器通讯，你不要关心你的本地端口号(就象你在使用 telnet 的时候)，你只要 简单的调用 connect() 就够可，他会检查套接口是否绑定，如果没有，他会自己绑定 一个没有使用的本地端口。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="connect()--Hello！">connect()&#8211;Hello！ </a>  
现在我们假设你是个 telnet 程序。你的用户命令你(就象电影 TRON 中一样)得到套接口 的文件描述符。你听从命令调用了 socket()。下一步，你的用户告诉你通过端口23(标 准 telnet 端口)连接到"132.241.5.10"。你该怎么做呢?   
幸运的是，你正在疯狂地阅读 connect()&#8211;如何连接到远程主机这一章。你可不想让 你的用户失望。   
connect() 系统调用是这样的：   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; <font color="#0000ff">int</font> connect(<font color="#0000ff">int</font> sockfd, <font color="#0000ff">struct</font> sockaddr *serv_addr, <font color="#0000ff">int</font> addrlen);   
sockfd 是系统调用 socket() 返回的套接口文件描述符。serv_addr 是保存着目的地端口和 IP 地址的数据结构 struct sockaddr。addrlen 设置为 sizeof(struct sockaddr)。   
让我们来看个例子：   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">define</font> DEST_IP&nbsp; "132.241.5.10"   
&nbsp; #<font color="#0000ff">define</font> DEST_PORT 23   
&nbsp; main()   
&nbsp; { <font color="#0000ff"><br /> </font>&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in dest\_addr;&nbsp; /\* will hold the destination addr \*/   
&nbsp;&nbsp;&nbsp;sockfd = socket(AF\_INET, SOCK\_STREAM, 0); /\* do some error checking! \*/   
&nbsp;&nbsp;&nbsp; dest\_addr.sin\_family = AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;/\* host byte order \*/   
&nbsp;&nbsp;&nbsp; dest\_addr.sin\_port = htons(DEST_PORT); /\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; dest\_addr.sin\_addr.s\_addr = inet\_addr(DEST_IP);   
&nbsp;&nbsp;&nbsp; bzero(&amp;(dest\_addr.sin\_zero), 8);&nbsp;&nbsp;&nbsp; /\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp; /\* don&#8217;t forget to error check the connect()! \*/   
&nbsp;&nbsp;&nbsp; connect(sockfd, (struct sockaddr *)&amp;dest_addr, <font color="#0000ff">sizeof</font>(<font color="#0000ff">struct</font> sockaddr));   
&nbsp;&nbsp;&nbsp; .   
&nbsp;&nbsp;&nbsp; .   
&nbsp;&nbsp;&nbsp; .   
再一次，你应该检查 connect() 的返回值&#8211;他在错误的时候返回-1，并 设置全局变量 errno。   
同时，你可能看到，我没有调用 bind()。另外，我也没有管本地的端口号。我只关心 我在连接。内核将为我选择一个合适的端口号，而我们所连接的地方也自动地获得这些信息。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="listen">listen</a>()&#8211;Will somebody please call me?   
Ok, time for a change of pace. What if you don&#8217;t want to connect to a remote host. Say, just for kicks, that you want to wait for incoming connections and handle them in some way. 处理过程分两步：首先，你听&#8211;listen()，然后，你接受&#8211;accept() (请看 下面的内容)。   
除了要一点解释外，系统调用 listen 相当简单。   
&nbsp;int listen(int sockfd, int backlog);   
sockfd 是调用 socket() 返回的套接口文件描述符。backlog 是 在进入队列中允许的连接数目。是什么意思呢? 进入的连接是在队列中一直等待直到你接受 (accept() 请看下面的文章)的连接。他们的数目限制于队列的允许。大多数系统的允许数目是20，你也可以设置为5到10。   
和别的函数一样，在发生错误的时候返回-1，并设置全局变量 errno。   
你可能想象到了，在你调用 listen() 前你或者要调用 bind() 或者让 内核随便选择一个端口。如果你想侦听进入的连接，那么系统调用的顺序可能是这样的：   
&nbsp; socket();   
&nbsp; bind();   
&nbsp; listen();   
&nbsp; /\* accept() goes here \*/   
因为他相当的明了，我将在这里不给出例子了。(在 accept() 那一章的代码将更加 完全。)真正麻烦的部分在 accept()。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="accept">accept</a>()&#8211;"Thank you for calling port 3490."   
准备好了，系统调用 accept() 会有点古怪的地方的！你可以想象发生这样的事情： 有人从很远的地方通过一个你在侦听 (listen()) 的端口连接 (connect()) 到你的机器。他的连接将加入到等待接受 (accept()) 的队列中。你调用 accept() 告诉他你有空闲的连接。他将返回一个新的套接口文件描述符！ 原来的一个还在侦听你的那个端口，新的最后在准备发送 (send()) 和接收 ( recv()) 数据。这就是这个过程！   
函数是这样定义的：   
&nbsp;&nbsp;#include &lt;sys/socket.h&gt;   
&nbsp;&nbsp;int accept(int sockfd, void \*addr, int \*addrlen);   
sockfd 相当简单，是和 listen() 中一样的套接口描述符。addr 是个指向局部的数据结构 struct sockaddr\_in 的指针。This is where the information about the incoming connection will go (and you can determine which host is calling you from which port). 在他的地址传递给 accept 之前，addrlen 是个局部的整形变量，设置为 sizeof(struct sockaddr\_in)。accept 将 不会将多余的字节给 addr。如果你放入的少些，那么在 addrlen 的值中反映 出来。   
同样，在错误时返回-1并设置全局变量 errno。   
现在是你应该熟悉的代码片段。   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">define</font> MYPORT 3490&nbsp;&nbsp;/\* the port users will be connecting to \*/   
&nbsp; #<font color="#0000ff">define</font> BACKLOG 10&nbsp;&nbsp; /\* how many pending connections queue will hold \*/   
&nbsp; <font color="#0000ff">main</font>()   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd, new\_fd;&nbsp;/\* listen on sock\_fd, new connection on new_fd \*/   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">struct</font> sockaddr\_in my\_addr;&nbsp;&nbsp;/\* my address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in their\_addr; /\* connector&#8217;s address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int </font>sin_size;   
&nbsp;&nbsp;&nbsp; sockfd = socket(AF\_INET, SOCK\_STREAM, 0); /\* do some error checking! \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_family = AF_INET;&nbsp;&nbsp;&nbsp;&nbsp; /\* host byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = htons(MYPORT);&nbsp;&nbsp; /\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = INADDR\_ANY; /\* auto-fill with my IP \*/   
&nbsp;&nbsp;&nbsp; bzero(&amp;(my\_addr.sin\_zero), 8);&nbsp;&nbsp;&nbsp;&nbsp;/\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp; /\* don&#8217;t forget your error checking for these calls: \*/   
&nbsp;&nbsp;&nbsp; bind(sockfd, (<font color="#0000ff">struct</font> sockaddr *)&amp;my_addr, <font color="#0000ff">sizeof</font>(struct sockaddr));   
&nbsp;&nbsp;&nbsp; listen(sockfd, BACKLOG);   
&nbsp;&nbsp;&nbsp;sin_size = sizeof(<font color="#0000ff">struct</font> sockaddr_in);   
&nbsp;&nbsp;&nbsp; new\_fd = accept(sockfd, &amp;their\_addr, &amp;sin_size);   
&nbsp;&nbsp;&nbsp; .   
&nbsp;&nbsp;&nbsp; .   
&nbsp;&nbsp;&nbsp; .   
注意，在系统调用 send() 和 recv() 中你应该使用新的文件描述符。 如果你只想让一个连接进来，那么你可以使用 close() 去关闭原来的文件描述 符 sockfd 来避免同一个端口更多的连接。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="send">send</a>() and recv()&#8211;Talk to me, baby!   
这两个函数用于流式套接口和数据报套接口的通讯。如果你喜欢使用无连接的数据报 套接口，你应该看一看下面关于 sendto() 和 recvfrom() 的章节。   
send() 是这样的：   
&nbsp; int send(int sockfd, const void *msg, int len, int flags);   
sockfd 是你想发送数据的套接口描述符(或者是调用 socket() 或者是 accept() 返回的。)msg 是指向你想发送的数据的指针。len 是 数据的长度。把 flags 设置为 0 就可以了。(详细的资料请看 send() 的 man page)。   
这里是一些可能的例子：   
&nbsp; <font color="#0000ff">char</font> *msg = "Beej was here!";   
&nbsp; <font color="#0000ff">int</font> len, bytes_sent;   
&nbsp; .   
&nbsp; .   
&nbsp; len = strlen(msg);   
&nbsp; bytes_sent = send(sockfd, msg, len, 0);   
&nbsp;.   
.   
&nbsp; .   
send() 返回实际发送的数据的字节数&#8211;他可能小于你要求发送的数目！也即你告诉他要发送一堆数据可是他不能处理成功。他只是发送他可能发送的数据，然后 希望你以后能够发送其他的数据。记住，如果 send() 返回的数据和 len 不 匹配，你应该发送其他的数据。但是这里也有个好消息：如果你要发送的包很小(小于大约 1K)，他可能处理让数据一次发送完。最后，在错误的时候返回-1，并设置 errno。   
recv() 函数很相似：   
&nbsp; <font color="#0000ff">int</font> recv(<font color="#0000ff">int</font> sockfd, <font color="#0000ff">void</font> *buf, <font color="#0000ff">int</font> len, <font color="#0000ff">unsigned</font> <font color="#0000ff">int</font> flags);   
sockfd 是要读的套接口描述符。buf 是要读的信息的缓冲。len 是 缓冲的最大长度。flags 也可以设置为0。(请参考recv() 的 man page。)   
recv() 返回实际读入缓冲的数据的字节数。或者在错误的时候返回-1，同时设置 errno。   
很简单，不是吗? 你现在可以在流式套接口上发送数据和接收数据了。你现在是 Unix 网络程序员了！   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="sendto">sendto</a>() 和 recvfrom()&#8211;Talk to me, DGRAM-style   
"这很不错啊"，我听到你说，"但是你还没有讲无连接数据报套接口呢。"没问题，现在我们开始 这个内容。   
既然数据报套接口不是连接到远程主机的，那么在我们发送一个包之前需要什么信息呢? 不错，是目标地址！看下面的：   
&nbsp; <font color="#0000ff">int</font> sendto(<font color="#0000ff">int</font> sockfd, <font color="#0000ff">const</font> <font color="#0000ff">void</font> *msg, <font color="#0000ff">int</font> len, <font color="#0000ff">unsigned</font> <font color="#0000ff">int</font> flags,   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">const</font> <font color="#0000ff">struct</font> sockaddr *to, <font color="#0000ff">int</font> tolen);   
你已经看到了，除了另外的两个信息外，其余的和函数 send() 是一样的。 to 是个指向数据结构 struct sockaddr 的指针，他包含了目的地的 IP 地址和断口信息。tolen 可以简单地设置为 sizeof(struct sockaddr)。   
和函数 send() 类似，sendto() 返回实际发送的字节数(他也可能小于你 想要发送的字节数！)，或者在错误的时候返回 -1。   
相似的还有函数 recv() 和 recvfrom()。recvfrom() 的定义是 这样的：   
&nbsp; <font color="#0000ff">int</font> recvfrom(<font color="#0000ff">int</font> sockfd, <font color="#0000ff">void</font> *buf, <font color="#0000ff">int</font> len, <font color="#0000ff">unsigned</font> <font color="#0000ff">int</font> flags   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">struct</font> sockaddr *from, in<font color="#0000ff">t</font> *fromlen);   
又一次，除了一点多余的参数外，这个函数和 recv() 也是一样的。from 是 一个指向局部数据结构 struct sockaddr 的指针，他的内容是源机器 的 IP 地址和端口信息。fromlen 是个 int 型的局部指针，他的初始值 为 sizeof(struct sockaddr)。函数调用后，fromlen 保存着 实际储存在 from 中的地址的长度。   
recvfrom() 返回收到的字节长度，或者在发生错误后返回 -1。   
记住，如果你是用 connect() 连接一个数据报套接口，你可以简单的调用 send() 和 recv() 来满足你的要求。这个时候依然是数据报套接口，依然使用 UDP，系统 自动的加上了目标和源的信息。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-   
<a name="close">close</a>() 和 shutdown()&#8211;Get outta my face!   
你已经整天都在发送 (send()) 和接收 (recv()) 数据了，现在你准备 关闭你的套接口描述符了。这很简单，你可以使用一般的 Unix 文件描述符的 close() 函 数：   
&nbsp; close(sockfd);   
他将防止套接口上更多的数据的读写。任何在另一端读写套接口的企图都将返回错误信息。   
如果你想在如何关闭套接口上有多一点的控制，你可以使用函数 shutdown()。他能够让 你将一定方向的通讯或者双向的通讯(就象 close() 一样)关闭，你可以使用：   
&nbsp; <font color="#0000ff">int</font> shutdown(<font color="#0000ff">int</font> sockfd, i<font color="#0000ff">n</font>t how);   
sockfd 是你想要关闭的套接口文件描述复。how 的值是下面的其中之一：   
0 &#8211; Further receives are disallowed   
1 &#8211; Further sends are disallowed   
2 &#8211; Further sends and receives are disallowed (和 close() 一样   
shutdown() 成功时返回 0，失败时返回 -1(同时设置 errno。)   
如果在无连接的数据报套接口中使用 shutdown()，那么只不过是让 send() 和 recv() 不能使用(记得你在数据报套接口中使用了 connect 后是可以 使用他们的吗?)   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="getpeername">getpeername</a>()&#8211;Who are you?   
这个函数太简单了。   
他太简单了，以至我都不想单列一章。但是我还是这样做了。   
函数 getpeername() 告诉你在连接的流式套接口上谁在另外一边。函数是这样的：   
&nbsp; #include &lt;sys/socket.h&gt;   
&nbsp; int getpeername(int sockfd, struct sockaddr \*addr, int \*addrlen);   
sockfd 是连接的流式套接口的描述符。addr 是一个指向结构 struct sockaddr (或者是 struct sockaddr_in) 的指针，他保存着 连接的另一边的信息。addrlen 是一个 int 型的指针，他初始化为 sizeof(struct sockaddr)。   
函数在错误的时候返回 -1，设置相应的 errno。   
一旦你获得他们的地址，你可以使用 inet_ntoa() 或者 gethostbyaddr() 来打印或者获得更多的信息。但是你不能得到他的帐号。(如果他运行着愚蠢的守护进程，这是 可能的，但是他的讨论已经超出了本文的范围，请参考 RFC-1413 以获得更多的信息。)   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-   
<a name="gethostname">gethostname</a>()&#8211;Who am I?   
甚至比 getpeername() 还简单的函数是 gethostname()。他返回你程序 所运行的机器的主机名字。然后你可以使用 gethostbyname() 以获得你的机器的 IP 地址。   
下面是定义：   
&nbsp; #include <unistd.h>   
&nbsp; int gethostname(char *hostname, size_t size);   
参数很简单：hostname 是一个字符数组指针，他将在函数返回时保存 主机名。size 是 hostname 数组的字节长度。   
函数调用成功时返回 0，失败时返回 -1，并设置 errno。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="DNS">DNS</a>&#8211;You say "whitehouse.gov", I say "198.137.240.100"   
如果你不知道 DNS 的意思，那么我告诉你，他代表"域名服务 (Domain Name Service)"。他主要的功能是：你给他一个容易记忆的某站点的地址，他给你 IP 地址(然后你就可以 使用 bind(), connect(), sendto() 或者其他函数。)当一个人 输入：   
&nbsp; $ telnet whitehouse.gov   
telnet 能知道他将连接 (connect()) 到 "198.137.240.100"。   
但是这是如何工作的呢? 你可以调用函数 gethostbyname()：   
&nbsp; #include <netdb.h>   
&nbsp; struct hostent \*gethostbyname(const char \*name);   
很明白的是，他返回一个指向 struct hostent 的指针。这个数据结构是 这样的：   
&nbsp; <font color="#0000ff">struct</font> hostent {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">char</font>&nbsp;&nbsp;*h_name;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">char</font>&nbsp;&nbsp;**h_aliases;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font>&nbsp;&nbsp; h_addrtype;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font>&nbsp;&nbsp; h_length;   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">char</font>&nbsp;&nbsp;**h\_addr\_list;   
&nbsp; };   
&nbsp; #<font color="#0000ff">define</font> h\_addr h\_addr_list[0]   
这里是这个数据结构的详细资料： struct hostent:   
h_name &#8211; Official name of the host.   
h_aliases &#8211; A NULL-terminated array of alternate names for the host.   
h\_addrtype &#8211; The type of address being returned; usually AF\_INET.   
h_length &#8211; The length of the address in bytes.   
h\_addr\_list &#8211; A zero-terminated array of network addresses for the host. Host addresses are in Network Byte Order.   
h\_addr &#8211; The first address in h\_addr_list.   
gethostbyname() 成功时返回一个指向 struct hostent 的 指针，或者是个空 (NULL) 指针。(但是和以前不同，errno 不设置，h_errno 设置错误信息。请看下面的 herror()。)   
但是如何使用呢? 这个函数可不象他看上去那么难用。   
这里是个例子：   
&nbsp; #<font color="#0000ff">include</font> <stdio.h>   
&nbsp; #<font color="#0000ff">include</font> <stdlib.h>   
&nbsp; #<font color="#0000ff">include</font> <errno.h>   
&nbsp; #<font color="#0000ff">include</font> <netdb.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;netinet/in.h&gt;   
&nbsp; <font color="#0000ff">int </font>main(int argc, char *argv[])   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> hostent *h;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> (argc != 2) {&nbsp;/\* error check the command line \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"usage: getip address\n");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; } <font color="#0000ff"><br /> </font>&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((h=gethostbyname(argv[1])) == NULL) {&nbsp;/\* get the host info \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; herror("gethostbyname");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">printf</font>("Host name&nbsp;: %s\n", h-&gt;h_name);   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">printf</font>("IP Address : %s\n",inet\_ntoa(\*((struct in\_addr \*)h-&gt;h_addr)));   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font> 0;   
&nbsp; }   
在使用 gethostbyname() 的时候，你不能用 perror() 打印错误信息(因 为 errno 没有使用)，你应该调用 herror()。   
相当简单，你只是传递一个保存机器名的自负串(例如 "whitehouse.gov") 给 gethostbyname()，然后从返回的数据结构 struct hostent 中 收集信息。   
唯一让人迷惑的是打印 IP 地址信息。h-&gt;h\_addr 是一个 char \*， 但是 inet\_ntoa() 需要的是 struct in\_addr。因此，我 转换 h-&gt;h\_addr 成 struct in_addr \*，然后得到数据。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="Client-Server Background">Client-Server Background </a>  
这里是个客户&#8211;服务器的世界。在网络上的所有东西都是在处理客户进程和服务器进程的交谈。 举个 telnet 的例子。当你用 telnet (客户)通过 23 号端口登陆到主机，主机上运行 的一个程序(一般叫 telnetd，服务器)激活。他处理这个连接，显示登陆界面，等等。   
Figure 2. The Client-Server Relationship.   
图 2 说明了客户和服务器之间的信息交换。   
注意，客&#8211;服务器之间可以使用SOCK\_STREAM、SOCK\_DGRAM 或者其他(只要他们采用相同的)。一些很好的客户&#8211;服务器的例子有 telnet/telnetd、 ftp/ftpd 和 bootp/bootpd。每次你使用 ftp 的 时候，在远端都有一个 ftpd 为你服务。   
一般，在服务端只有一个服务器，他采用 fork() 来处理多个客户的连接。基本的 程序是：服务器等待一个连接，接受 (accept()) 连接，然后 fork() 一个 子进程处理他。这是下一章我们的例子中会讲到的。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="简单的服务器">简单的服务器 </a>  
这个服务器所做的全部工作是在留式连接上发送字符串 "Hello, World!\n"。你要 测试这个程序的话，可以在一台机器上运行该程序，然后在另外一机器上登陆：   
&nbsp; $ telnet remotehostname 3490   
remotehostname 是该程序运行的机器的名字。   
服务器代码：   
&nbsp; #<font color="#0000ff">include</font> <stdio.h>   
&nbsp; #<font color="#0000ff">include</font> <stdlib.h>   
&nbsp; #<font color="#0000ff">include</font> <errno.h>   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;netinet/in.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/wait.h&gt;   
&nbsp; #<font color="#0000ff">define</font> MYPORT 3490&nbsp;&nbsp;/\* the port users will be connecting to \*/   
&nbsp; #<font color="#0000ff">define</font> BACKLOG 10&nbsp;&nbsp; /\* how many pending connections queue will hold \*/   
&nbsp; <font color="#0000ff">main</font>()   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd, new\_fd;&nbsp;/\* listen on sock\_fd, new connection on new_fd \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in my\_addr;&nbsp;&nbsp;/\* my address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in their\_addr; /\* connector&#8217;s address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sin_size;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((sockfd = socket(AF\_INET, SOCK\_STREAM, 0)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("socket");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_family = AF_INET;&nbsp;&nbsp;&nbsp;&nbsp; /\* host byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = htons(MYPORT);&nbsp;&nbsp; /\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = INADDR\_ANY; /\* auto-fill with my IP \*/   
&nbsp;&nbsp;&nbsp; bzero(&amp;(my\_addr.sin\_zero), 8);&nbsp;&nbsp;&nbsp;&nbsp;/\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr)) \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("bind");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if </font>(listen(sockfd, BACKLOG) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("listen");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">while</font>(1) {&nbsp;/\* main accept() loop \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sin\_size = sizeof(struct sockaddr\_in);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((new\_fd = accept(sockfd, (struct sockaddr *)&amp;their\_addr, \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;sin_size)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("accept");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("server: got connection from %s\n", \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet\_ntoa(their\_addr.sin_addr));   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> (!fork()) { /\* this is the child process \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (send(new_fd, "Hello, world!\n", 14, 0) == -1)   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("send");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">close</font>(new_fd);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(0);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(new_fd);&nbsp;/\* parent doesn&#8217;t need this \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">while</font>(waitpid(-1,NULL,WNOHANG) &gt; 0); /\* clean up child processes \*/   
&nbsp;&nbsp;&nbsp; }   
&nbsp; }   
如果你很挑剔的话，一定不满意我所有的代码都在一个很大的 main() 函数 中。如果你不喜欢，可以划分得更细点。   
你也可以用我们下一章中的程序得到服务器端发送的字符串。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="简单的客户程序">简单的客户程序</a>   
这个程序比服务器还简单。这个程序的所有工作是通过 3490 端口连接到命令行中制定的主机， 然后得到服务器的字符串。   
客户代码:   
&nbsp; #<font color="#0000ff">include</font> <stdio.h>   
&nbsp; #<font color="#0000ff">include</font> <stdlib.h>   
&nbsp; #<font color="#0000ff">include</font> <errno.h>   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> <netdb.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;netinet/in.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">define</font> PORT 3490&nbsp;&nbsp;/\* the port client will be connecting to \*/   
&nbsp; #<font color="#0000ff">define</font> MAXDATASIZE 100 /\* max number of bytes we can get at once \*/   
&nbsp; <font color="#0000ff">int</font> main(<font color="#0000ff">i</font>nt argc, <font color="#0000ff">char</font> *argv[])   
&nbsp; {   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> sockfd, numbytes;&nbsp;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">char</font> buf[MAXDATASIZE];   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> hostent *he;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in their\_addr; /\* connector&#8217;s address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if </font>(argc != 2) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"usage: client hostname\n");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((he=gethostbyname(argv[1])) == NULL) {&nbsp;/\* get the host info \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; herror("gethostbyname");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((sockfd = socket(AF\_INET, SOCK\_STREAM, 0)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("socket"); </netdb.h></string.h></errno.h></stdlib.h></stdio.h></string.h></errno.h></stdlib.h></stdio.h></netdb.h></errno.h></stdlib.h></stdio.h></netdb.h></unistd.h></string.h></string.h></string.h></p>

<p>      exit(1); </p>

<p>    } </p>

<p>    their_addr.sin_family = AF_INET;   /* host byte order */ </p>

<p>    their_addr.sin_port = htons(PORT);  /* short, network byte order */ </p>

<p>    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr); </p>

<p>    bzero(&amp;(their_addr.sin_zero), 8);   /* zero the rest of the struct */ </p>

<p>    <font color="#0000ff">if</font> (connect(sockfd, (struct sockaddr *)&amp;their_addr, \ <br />
                      sizeof(struct sockaddr)) == -1) { <br />
      perror(“connect”); <br />
     exit(1); <br />
   } <br />
    <font color="#0000ff">if</font> ((numbytes=recv(sockfd, buf, MAXDATASIZE, 0)) == -1) { <br />
      perror(“recv”); <br />
     exit(1); <br />
    } <br />
    buf[numbytes] = ‘\0′; <br />
    printf(“Received: %s”,buf); <br />
   close(sockfd); <br />
    <font color="#0000ff">return</font> 0; <br />
  } <br />
注意，如果你在运行服务器之前运行客户程序，connect() 将返回 “Connection refused” 信息。 <br />
——————————————————————————– <br />
<a name="数据报 Sockets">数据报 Sockets </a><br />
我不想讲更多了，所以我给出代码 talker.c 和 listener.c。 <br />
listener 在机器上等待在端口 4590 来的数据包。talker 发送数据包到一定的 机器，他包含用户在命令行输入的东西。 <br />
这里就是 listener.c： <br />
  #<font color="#0000ff">include</font> <stdio.h>   
&nbsp; #<font color="#0000ff">include</font> <stdlib.h>   
&nbsp; #<font color="#0000ff">include</font> <errno.h>   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;netinet/in.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/wait.h&gt;   
&nbsp; #<font color="#0000ff">define</font> MYPORT 4950&nbsp;&nbsp;/\* the port users will be sending to \*/   
&nbsp; #<font color="#0000ff">define</font> MAXBUFLEN 100   
&nbsp; <font color="#0000ff">main</font>()   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in my\_addr;&nbsp;&nbsp;/\* my address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in their\_addr; /\* connector&#8217;s address information \*/   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> addr_len, numbytes;   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">char</font> buf[MAXBUFLEN];   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((sockfd = socket(AF\_INET, SOCK\_DGRAM, 0)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("socket");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp;}   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_family = AF_INET;&nbsp;&nbsp;&nbsp;&nbsp; /\* host byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_port = htons(MYPORT);&nbsp;&nbsp; /\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; my\_addr.sin\_addr.s\_addr = INADDR\_ANY; /\* auto-fill with my IP \*/   
&nbsp;&nbsp;&nbsp; bzero(&amp;(my\_addr.sin\_zero), 8);&nbsp;&nbsp;&nbsp;&nbsp;/\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr)) \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;== -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("bind");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp;}   
&nbsp;&nbsp;&nbsp; addr_len = sizeof(struct sockaddr);   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((numbytes=recvfrom(sockfd, buf, MAXBUFLEN, 0, \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct sockaddr *)&amp;their\_addr, &amp;addr\_len)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("recvfrom");   
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; printf("got packet from %s\n",inet\_ntoa(their\_addr.sin_addr));   
&nbsp;&nbsp;&nbsp; printf("packet is %d bytes long\n",numbytes);   
&nbsp;&nbsp;&nbsp; buf[numbytes] = &#8216;\0&#8242;;   
&nbsp;&nbsp;&nbsp; printf("packet contains \"%s\"\n",buf);   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">close</font>(sockfd);   
&nbsp; }   
注意在我们的调用 socket()，我们最后使用了 SOCK_DGRAM。同时，没有 必要去使用 listen() 或者 accept()。我们在使用无连接的数据报套接口！   
下面是 talker.c：   
&nbsp; #<font color="#0000ff">include</font> <stdio.h>   
&nbsp; #<font color="#0000ff">include</font> <stdlib.h>   
&nbsp; #<font color="#0000ff">include</font> <errno.h>   
&nbsp; #<font color="#0000ff">include</font> <string.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;netinet/in.h&gt;   
&nbsp;#<font color="#0000ff">include</font> <netdb.h>   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/socket.h&gt;   
&nbsp; #<font color="#0000ff">include</font> &lt;sys/wait.h&gt;   
&nbsp; #<font color="#0000ff">define</font> MYPORT 4950&nbsp;&nbsp;/\* the port users will be sending to \*/   
&nbsp; <font color="#0000ff">int</font> main(<font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> *argv[])   
&nbsp; {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> sockfd;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> sockaddr\_in their\_addr; /\* connector&#8217;s address information \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">struct</font> hostent *he;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> numbytes;   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> (argc != 3) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"usage: talker hostname message\n");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((he=gethostbyname(argv[1])) == NULL) {&nbsp;/\* get the host info \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; herror("gethostbyname");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((sockfd = socket(AF\_INET, SOCK\_DGRAM, 0)) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("socket");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp;their\_addr.sin\_family = AF_INET;&nbsp;&nbsp;&nbsp;/\* host byte order \*/   
&nbsp;&nbsp;&nbsp; their\_addr.sin\_port = htons(MYPORT);&nbsp;/\* short, network byte order \*/   
&nbsp;&nbsp;&nbsp; their\_addr.sin\_addr = \*((struct in\_addr \*)he-&gt;h\_addr);   
&nbsp;&nbsp;&nbsp; bzero(&amp;(their\_addr.sin\_zero), 8);&nbsp;&nbsp; /\* zero the rest of the struct \*/   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0, \   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr))) == -1) {   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("sendto");   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">exit</font>(1);   
&nbsp;&nbsp;&nbsp; }   
&nbsp;&nbsp;&nbsp; printf("sent %d bytes to %s\n",numbytes,inet\_ntoa(their\_addr.sin_addr));   
&nbsp;&nbsp;&nbsp; close(sockfd);   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font> 0;   
&nbsp; }   
这就是所有的了。在一台机器上运行 listener，然后在另外一台机器上运行 talker。观察他们的通讯！   
Except for one more tiny detail that I&#8217;ve mentioned many times in the past: connected datagram sockets. I need to talk about this here, since we&#8217;re in the datagram section of the document. Let&#8217;s say that talker calls connect() and specifies the listener&#8217;s address. From that point on, talker may only sent to and receive from the address specified by connect(). For this reason, you don&#8217;t have to use sendto() and recvfrom(); you can simply use send() and recv().   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="阻塞">阻塞 </a>  
阻塞，你也许早就听说了。"阻塞"是 "sleep" 的科技行话。你可能注意到前面运行的 listener 程序，他在那里不停地运行，等待数据包的到来。实际在运行的是 他调用 recvfrom()，然后没有数据，因此 recvfrom() 说"阻塞 (block)" 直到数据的到来。   
很多函数都利用阻塞。accept() 阻塞，所有的 recv*() 函数阻塞。他们之所以能这样做是因为他们被允许这样做。当你第一次调用 socket() 建立套接口描述符的时候，内核就将他设置为阻塞。如果你不想套接口阻塞，你就要调用函数 fcntl()：   
&nbsp; #<font color="#0000ff">include</font> <unistd.h>   
&nbsp; #<font color="#0000ff">include</font> <fcntl.h>   
&nbsp;.   
&nbsp;.   
&nbsp; sockfd = socket(AF\_INET, SOCK\_STREAM, 0);   
&nbsp; fcntl(sockfd, F\_SETFL, O\_NONBLOCK);   
&nbsp; .   
&nbsp; .   
通过设置套接口为非阻塞，你能够有效地"询问"套接口以获得信息。如果你尝试着 从一个非阻塞的套接口读信息并且没有任何数据，他不会变成阻塞&#8211;他将返回 -1 并 将 errno 设置为 EWOULDBLOCK。   
但是一般说来，这种轮询不是个好主意。如果你让你的程序在忙等状态查询套接口的数据， 你将浪费大量的 CPU 时间。更好的解决之道是用下一章讲的 select() 去查询 是否有数据要读进来。   
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;   
<a name="select()--多路同步 I/O">select()&#8211;多路同步 I/O </a>  
虽然这个函数有点奇怪，但是他很有用。假设这样的情况：你是个服务器，你一边在不停地 从连接上读数据，一边在侦听连接上的信息。   
没问题，你可能会说，不就是一个 accept() 和两个 recv() 吗? 这么容易 吗，朋友? 如果你在调用 accept() 的时候阻塞呢? 你怎么能够同时接受 recv() 数据? "用非阻塞的套接口啊！" 不行！你不想耗尽所有的 CPU，不是吗? 那么，该如何是好?   
select() 让你可以同时监视多个套接口。如果你想知道的话，那么他就会告诉你哪个套接口准备读，哪个又 准备好了写，哪个套接口又发生了例外 (exception)。   
闲话少说，下面是 select()：   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">include</font> &lt;sys/time.h&gt;   
&nbsp;&nbsp; #<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">include</font> <unistd.h>   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> <font color="#0000ff">select</font>(<font color="#0000ff">int</font> numfds, fd\_set \*readfds, fd\_set \*writefds,   
<font color="#0000ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>fd_set *exceptfds, <font color="#0000ff">struct</font> timeval *timeout);   
这个函数监视一系列文件描述符，特别是 readfds、writefds 和 exceptfds。如果你想知道你是否能够从标准输入和套接口描述符 sockfd 读 入数据，你只要将文件描述符 0 和 sockfd 加入到集合 readfds 中。 参数 numfds 应该等于最高的文件描述符的值加1。在这个例子中，你应该设置该值 为 sockfd+1。因为他一定大于标准输入的文件描述符 (0)。   
当函数 select() 返回的时候，readfds 的值修改为反映你选择的哪个文件 描述符可以读。你可以用下面讲到的宏 FD_ISSET() 来测试。   
在我们继续下去之前，让我来讲讲如何对这些集合进行操作。每个集合类型都是 fd_set。 下面有一些宏来对这个类型进行操作：   
FD\_ZERO(fd\_set *set) &#8211; clears a file descriptor set   
FD\_SET(int fd, fd\_set *set) &#8211; adds fd to the set   
FD\_CLR(int fd, fd\_set *set) &#8211; removes fd from the set   
FD\_ISSET(int fd, fd\_set *set) &#8211; tests to see if fd is in the set   
最后，是有点古怪的数据结构 struct timeval。有时你可不想永远等待别人发送数据过来。也许什么事情都没有发生的时候你也想每隔96秒在终端 上打印字符串 "Still Going&#8230;"。这个数据结构允许你设定一个时间，如果时间到了， 而 select() 还没有找到一个准备好的文件描述符，他将返回让你继续处理。   
数据结构 struct timeval 是这样的：   
&nbsp; <font color="#0000ff">struct</font> timeval {   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> tv_sec;&nbsp;&nbsp; /\* seconds \*/   
&nbsp;&nbsp;&nbsp; <font color="#0000ff">int</font> tv_usec;&nbsp;&nbsp;/\* microseconds \*/   
&nbsp; };   
只要将 tv\_sec 设置为你要等待的秒数，将 tv\_usec 设置为你要等待的微秒数就可以了。是的，是微秒而不是毫秒。1,000微秒等于1豪秒，1,000毫秒等于1秒。也就是说，1秒等于1,000,000微秒。为什么用符号 "usec" 呢? 字母 "u" 很象希腊字母 Mu， 而 Mu 表示 "微" 的意思。当然，函数返回的时候 timeout 可能是剩余的 时间，之所以是可能，是因为他依赖于你的 Unix 操作系统。   
哈！我们现在有一个微秒级的定时器！不要计算了，标准的 Unix 系统的时间片是100毫秒，所以 无论你如何设置你的数据结构 struct timeval，你都要等待那么长的 时间。   
还有一些有趣的事情：如果你设置数据结构 struct timeval 中的 数据为 0，select() 将立即超时，这样就可以有效地轮询集合中的 所有的文件描述符。如果你将参数 timeout 赋值为 NULL，那么将永远不会发生超时，即一直等到第一个文件描述符就绪。最后，如果你不是很关心等待多长时间，那么 就把他赋为 NULL 吧。   
下面的代码演示了在标准输入上等待 2.5 秒：   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">include</font> &lt;sys/time.h&gt;   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">include</font> &lt;sys/types.h&gt;   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">include</font> <unistd.h>   
&nbsp;&nbsp;&nbsp;#<font color="#0000ff">define</font> STDIN 0&nbsp;/\* file descriptor for standard input \*/   
&nbsp;&nbsp;&nbsp;<font color="#0000ff">main</font>()   
&nbsp;&nbsp;&nbsp;{   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">struct</font> timeval tv;   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_set readfds;   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tv_sec = 2;   
&nbsp;&nbsp;&nbsp;&nbsp; tv.tv_usec = 500000;   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;readfds);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(STDIN, &amp;readfds);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\* don&#8217;t care about writefds and exceptfds: \*/   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select(STDIN+1, &amp;readfds, <font color="#0000ff">NULL</font>, <font color="#0000ff">NULL</font>, &amp;tv);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (FD_ISSET(STDIN, &amp;readfds))   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> </font>printf("A key was pressed!\n");   
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">else</font>   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Timed out.\n");   
&nbsp;&nbsp;}   
如果你是在一个 line buffered 终端上，那么你敲的键应该是回车 (RETURN)，否则无论如何 他都会超时。   
现在，你可能回认为这就是在数据报套接口上等待数据的方式&#8211;你是对的：他可能是。 有些 Unix 系统可以按这种方式，而另外一些则不能。你在尝试以前可能要先看看本系统 的 man page 了。   
最后一件关于 select() 的事情：如果你有一个正在侦听 (listen()) 的套接口，你可以通过将该套接口的文件描述符加入到 readfds 集合中来看 是否有新的连接。   
这就是我关于函数 select() 要讲的所有的东西。</unistd.h></unistd.h></fcntl.h></unistd.h></netdb.h></string.h></errno.h></stdlib.h></stdio.h></string.h></errno.h></stdlib.h></stdio.h></p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Your awesome title</li>
          <li><a href="mailto:your-email@domain.com">your-email@domain.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jekyll">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">jekyll</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/jekyllrb">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">jekyllrb</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
